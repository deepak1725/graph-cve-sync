#!/usr/bin/env python3
# Copyright Â© 2020 Red Hat Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Author: Yusuf Zainee <yzainee@redhat.com>
#

"""Script which synchronizes snyk CVEs from S3 to graph."""

from datetime import datetime, timedelta
import boto3
import json
import os
from f8a_utils.versions import get_versions_for_ep
from semantic_version import Version, NpmSpec
from unified_range import api
from f8a_version_comparator.comparable_version import ComparableVersion
import re
import logging
from requests_futures.sessions import FuturesSession
import time


logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
_session = FuturesSession(max_workers=500)


diff_fields = ['cves', 'exploit', 'cwes', 'fixable',
               'initiallyFixedIn', 'malicious', 'vulnerableVersions', 'severity']


class Helper:
    """Helper class with some utility functions."""

    def __init__(self):
        """Init method for helper class."""
        self.CVE_BUCKET = os.environ.get("REPORT_BUCKET_NAME", '')
        self.AWS_KEY = os.environ.get("AWS_S3_ACCESS_KEY_ID_REPORT_BUCKET", '')
        self.AWS_SECRET = os.environ.get("AWS_S3_SECRET_ACCESS_KEY_REPORT_BUCKET", '')
        self.AWS_REGION = os.environ.get("AWS_S3_REGION", "us-east-1")
        self.HOST = os.environ.get('BAYESIAN_DATA_IMPORTER_SERVICE_HOST', 'bayesian-data-importer')
        self.PORT = os.environ.get('BAYESIAN_DATA_IMPORTER_SERVICE_PORT', '9192')

        self.s3_resource = boto3.resource('s3', aws_access_key_id=self.AWS_KEY,
                                          aws_secret_access_key=self.AWS_SECRET,
                                          region_name=self.AWS_REGION)

    def store_json_content(self, content, obj_key):
        """Store the report content to the S3 storage."""
        try:
            logger.info('Storing the report into the S3 file %s' % obj_key)
            self.s3_resource.Object(self.CVE_BUCKET, obj_key).put(
                Body=json.dumps(content, indent=2).encode('utf-8'))
        except Exception as e:
            logger.exception('%r' % e)

    def retrieve_dict(self, object_key):
        """Retrieve a dictionary stored as JSON from S3."""
        return json.loads(self.retrieve_blob(object_key).decode())

    def retrieve_blob(self, object_key):
        """Retrieve remote object content."""
        return self.s3_resource.Object(self.CVE_BUCKET, object_key).get()['Body'].read()

    def read_data_from_s3(self, date, loc):
        """Read the snyk data from S3."""
        try:
            filename = loc + date + ".json"
            return self.retrieve_dict(filename)
        except Exception as e:
            logger.error(e)
            return False

    def make_api_call(self, payload):
        """Make an API call to data importer."""
        try:
            api_url = self.HOST + ":" + self.PORT
            _session.headers['Content-Type'] = "application/json"
            _session.put('{}/api/v1/snyk-cves'.format(api_url),
                         data=json.dumps(payload))
        except Exception:
            logger.error("API call to data importer failed.")

    def is_dry_run(self):
        """Return True if this is a dry run."""
        return os.environ.get('DRY_RUN', 'false').lower() in ('1', 'yes', 'true')

    def force_run_ingestion(self):
        """Return if ingestion mode is on."""
        return os.environ.get('SNYK_INGESTION_FORCE_RUN', 'false').lower() in ('1', 'yes', 'true')


class SnykCveSync:
    """Snyk class to sync cves to graph."""

    def __init__(self):
        """Init method for helper class."""
        self.helper = Helper()
        self.CVE_DATA = {}

    def get_version_rules_npm(self, vuln_versions):
        """Version rules for npm eco."""
        rules = []
        for version in vuln_versions:
            rules.append(NpmSpec(version))
        return rules

    def get_version_rules(self, vuln_versions):
        """Version rules for pypi,maven eco."""
        rules = []
        regex_op = "[0-9a-zA-Z.]+"
        regex_vr = "[<>=]+"
        for version in vuln_versions:
            if '||' in version:
                sub_vers = version.split(' || ')
                for sub_ver in sub_vers:
                    tmp = []
                    relations = sub_ver.split()
                    for rel in relations:
                        if not re.match(regex_vr, rel):
                            rel = "=" + rel
                        op = re.split(regex_op, rel)[0]
                        vr = re.split(regex_vr, rel)[1]
                        tmp.append({
                            'key': op,
                            'val': ComparableVersion(vr)
                        })
                    rules.append(tmp)
            else:
                tmp = []
                relations = version.split()
                for rel in relations:
                    if not re.match(regex_vr, rel):
                        rel = "=" + rel
                    op = re.split(regex_op, rel)[0]
                    vr = re.split(regex_vr, rel)[1]
                    tmp.append({
                        'key': op,
                        'val': ComparableVersion(vr)
                    })
                rules.append(tmp)

        return rules

    def is_relation_applicable(self, key, version, rule):
        """Check if the version satisfies the relation."""
        if key == '<':
            return ComparableVersion(version) < rule
        elif key == '>':
            return ComparableVersion(version) > rule
        elif key == '=':
            return ComparableVersion(version) == rule
        elif key == '<=':
            return ComparableVersion(version) <= rule
        elif key == '>=':
            return ComparableVersion(version) >= rule

    def get_affected_versions(self, rules, versions):
        """Get affected versions for maven, pypi."""
        affected = []
        for ver in versions:
            for rule in rules:
                if len(rule) == 1:
                    if self.is_relation_applicable(rule[0]['key'], ver, rule[0]['val']):
                        affected.append(ver)
                elif len(rule) == 2:
                    key0 = rule[0]['key']
                    key1 = rule[1]['key']
                    first = self.is_relation_applicable(key0, ver, rule[0]['val'])
                    second = self.is_relation_applicable(key1, ver, rule[1]['val'])
                    if first and second:
                        affected.append(ver)
                    else:
                        if '=' in key0:
                            if self.is_relation_applicable("=", ver, rule[0]['val']):
                                affected.append(ver)
                        elif '=' in key1:
                            if self.is_relation_applicable("=", ver, rule[1]['val']):
                                affected.append(ver)
        return list(set(affected))

    def get_affected_versions_npm(self, rules, versions):
        """Get affected versions for npm."""
        affected = []
        for ver in versions:
            for rule in rules:
                if Version(ver) in rule:
                    affected.append(ver)
                    break
        return list(set(affected))

    def get_semver_versions(self, versions):
        """Convert to semver version format."""
        semver = []
        for ver in versions:
            semver.append(api.to_semver(ver))
        return semver

    def extract_data_from_feed(self, data):
        """Fetch all the required info from the feed."""
        for eco in data:
            if eco == "java":
                self.parse_maven_data(data[eco])
            elif eco == "js":
                self.parse_npm_data(data[eco])
            elif eco == "python":
                self.parse_pypi_data(data[eco])

    def parse_maven_data(self, maven_data):
        """Parse data for maven."""
        if len(maven_data) != 0:
            self.CVE_DATA['maven'] = {}
            for data in maven_data:
                pkg = data['package']
                try:
                    versions = get_versions_for_ep('maven', pkg)
                    if versions:
                        if pkg not in self.CVE_DATA['maven']:
                            self.CVE_DATA['maven'][pkg] = []
                        data['ecosystem'] = "maven"
                        vuln_versions = self.get_semver_versions(data['vulnerableVersions'])
                        data['rules'] = self.get_version_rules(vuln_versions)
                        data['affected'] = self.get_affected_versions(data['rules'], versions)
                        del data['rules']
                        data['description'] = re.sub("[\'\"]", "", data['description'])
                        if len(data['cves']) == 0:
                            data['pvtVuln'] = True
                        else:
                            data['pvtVuln'] = False
                        self.CVE_DATA['maven'][pkg].append(data)
                except ValueError:
                    logger.error("Encountered an error while trying to fetch versions for "
                                 "maven -> {}".format(pkg))
        logger.info("Maven Data".center(50, '-'))
        logger.info(len(self.CVE_DATA['maven']))
        logger.info(self.CVE_DATA['maven'])

    def parse_pypi_data(self, pypi_data):
        """Parse data for pypi."""
        pypi_pkg_versions = {}
        if len(pypi_data) != 0:
            self.CVE_DATA['pypi'] = {}
            for data in pypi_data:
                pkg = data['package']
                try:
                    if pkg in pypi_pkg_versions:
                        versions = pypi_pkg_versions[pkg]
                    else:
                        versions = get_versions_for_ep('pypi', pkg)
                    if versions:
                        data['ecosystem'] = "pypi"
                        pypi_pkg_versions[pkg] = versions
                        if pkg not in self.CVE_DATA['pypi']:
                            self.CVE_DATA['pypi'][pkg] = []
                        vuln_versions = self.get_semver_versions(data['vulnerableVersions'])
                        data['rules'] = self.get_version_rules(vuln_versions)
                        data['affected'] = self.get_affected_versions(data['rules'], versions)
                        del data['rules']
                        if len(data['cves']) == 0:
                            data['pvtVuln'] = True
                        else:
                            data['pvtVuln'] = False
                        data['description'] = re.sub("[\'\"]", "", data['description'])
                        self.CVE_DATA['pypi'][pkg].append(data)

                except ValueError:
                    logger.error("Encountered an error while trying to fetch versions for "
                                 "pypi -> {}".format(pkg))
        logger.info("Pypi Data".center(50, '-'))
        logger.info(len(self.CVE_DATA['pypi']))
        logger.info(self.CVE_DATA['pypi'])

    def parse_npm_data(self, npm_data):
        """Parse data for npm."""
        if len(npm_data) != 0:
            self.CVE_DATA['npm'] = {}
            for data in npm_data:
                pkg = data['package']
                try:
                    versions = get_versions_for_ep('npm', pkg)
                    if versions:
                        data['ecosystem'] = "npm"
                        if pkg not in self.CVE_DATA['npm']:
                            self.CVE_DATA['npm'][pkg] = []
                        data['rules'] = self.get_version_rules_npm(data['vulnerableVersions'])
                        data['affected'] = self.get_affected_versions_npm(data['rules'], versions)
                        del data['rules']
                        if len(data['cves']) == 0:
                            data['pvtVuln'] = True
                        else:
                            data['pvtVuln'] = False
                        data['description'] = re.sub("[\'\"]", "", data['description'])
                        self.CVE_DATA['npm'][pkg].append(data)
                except ValueError:
                    logger.error("Encountered an error while trying to fetch versions for "
                                 "npm -> {}".format(pkg))
        logger.info("NPM Data".center(50, '-'))
        logger.info(len(self.CVE_DATA['npm']))
        logger.info(self.CVE_DATA['npm'])

    def insert_cves(self):
        """Insert the cve data for each ecosystem."""
        logger.info("Insertion of data begins".center(50, '-'))
        dry_run = self.helper.is_dry_run()
        if "maven" in self.CVE_DATA:
            logger.info("Inserting Maven CVEs...")
            for pkg in self.CVE_DATA['maven']:
                cves = self.CVE_DATA['maven'][pkg]
                if len(cves) > 0:
                    for cve_info in cves:
                        logger.info(cve_info)
                        if not dry_run:
                            self.helper.make_api_call(cve_info)
                        logger.info("Waiting for 3 seconds".center(30, '-'))
                        time.sleep(3)

        if "npm" in self.CVE_DATA:
            logger.info("Inserting NPM CVEs...")
            for pkg in self.CVE_DATA['npm']:
                cves = self.CVE_DATA['npm'][pkg]
                if len(cves) > 0:
                    for cve_info in cves:
                        logger.info(cve_info)
                        if not dry_run:
                            self.helper.make_api_call(cve_info)
                        logger.info("Waiting for 3 seconds".center(30, '-'))
                        time.sleep(3)

        if "pypi" in self.CVE_DATA:
            logger.info("Inserting PyPi CVEs...")
            for pkg in self.CVE_DATA['pypi']:
                cves = self.CVE_DATA['pypi'][pkg]
                if len(cves) > 0:
                    for cve_info in cves:
                        logger.info(cve_info)
                        if not dry_run:
                            self.helper.make_api_call(cve_info)
                        logger.info("Waiting for 3 seconds".center(30, '-'))
                        time.sleep(3)
        return True

    def disable_snyk_run(self, date):
        """Enable or disable snyk run."""
        force = self.helper.force_run_ingestion()
        if force:
            return False
        return date.strftime('%H') != '06'

    def run_snyk_sync(self):
        """Entrypoint for the snyk cve sync process."""
        logger.info("Running Snyk Sync".center(50, '-'))
        utc_now = datetime.utcnow()
        # TBD. comparison with prev day's feed for ingestion
        date_yest = (utc_now - timedelta(days=1)).strftime('%d%m%y')
        logger.info(utc_now)
        if self.disable_snyk_run(utc_now):
            logger.info("Snyk sync to run only once a day. Won't run at this hour.")
            return
        data = self.helper.read_data_from_s3(utc_now.strftime('%d-%m-%y'), "snyk-feed/")
        data_yest = self.helper.read_data_from_s3(date_yest, "snyk-feed/")
        # TBD add logic for comparison and use delta info for cve ingestion
        logger.debug(data_yest)
        if data:
            self.extract_data_from_feed(data)
            self.insert_cves()
        else:
            logger.info("No data found. Snyk sync aborted.")
        logger.info("Snyk Sync Completed".center(50, '-'))
        return "Success"
